<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Chart</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self' data: blob: qrc:;
                 script-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: qrc:;
                 style-src 'self' 'unsafe-inline';
                 img-src 'self' data: blob:;">
  <style>
    html, body { height:100%; margin:0; background:#0e1116; color:#cfd3dc; overflow:hidden; }
    #root { position:fixed; inset:0; display:flex; flex-direction:column; gap:6px; padding:0 0 40px 0; }
    .pane { width:100%; position:relative; }
    #pricePane { flex: 1 1 auto; min-height: 240px; }
    #rsiPane, #macdPane { height: 160px; flex: 0 0 auto; display:none; }

    .closeBtn {
      position:absolute; right:8px; top:8px; z-index:5;
      width:20px; height:20px; border-radius:4px; border:1px solid #334155;
      background:#111827; color:#e5e7eb; font: 700 12px/18px system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      text-align:center; cursor:pointer; user-select:none;
    }
    .closeBtn:hover { background:#0b1220; }

    #loading { position:fixed; inset:0; display:none; pointer-events:none; align-items:center; justify-content:center;
      background: rgba(0,0,0,0.35); backdrop-filter: blur(2px);
      font: 600 16px system-ui, -apple-system, Segoe UI, Roboto, sans-serif; color:#cfd3dc; z-index:9; }
    #spinner { width:28px; height:28px; border-radius:50%; border:3px solid #6b7280; border-top-color:#e5e7eb; animation: spin .9s linear infinite; margin-right:10px; }
    @keyframes spin { to { transform:rotate(360deg); } }

    #liveBtn {
      position: fixed; right: 12px; bottom: 12px; z-index: 10;
      display: inline-flex; align-items: center; gap: 8px;
      padding: 6px 12px; border-radius: 999px; border: 1px solid #334155;
      background: #111827; color: #e5e7eb; font: 600 12px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      cursor: pointer; user-select: none; box-shadow: 0 2px 6px rgba(0,0,0,.35);
    }
    #liveBtn:hover { background: #0b1220; }
    #liveBtn .dot { width: 8px; height: 8px; border-radius: 999px; background: #9ca3af; box-shadow: 0 0 0 2px rgba(255,255,255,.06) inset; }
    #liveBtn.live .dot { background: #22c55e; }
  </style>
  <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
  <script src="js/lightweight-charts.standalone.production.js"></script>
</head>
<body>
  <div id="root">
    <div id="pricePane" class="pane"></div>
    <div id="rsiPane" class="pane"><div id="rsiClose" class="closeBtn" title="Fermer RSI">✕</div></div>
    <div id="macdPane" class="pane"><div id="macdClose" class="closeBtn" title="Fermer MACD">✕</div></div>
  </div>

  <div id="loading"><div id="spinner"></div><div>Loading…</div></div>
  <button id="liveBtn" title="Revenir au live"><span class="dot"></span>LIVE</button>

<script>

  let HAS_INITIAL = false;

  const MAX_MARKERS = 600;

  const root = document.getElementById('root');
  const priceDiv = document.getElementById('pricePane');
  const rsiDiv = document.getElementById('rsiPane');
  const macdDiv = document.getElementById('macdPane');
  const rsiClose = document.getElementById('rsiClose');
  const macdClose = document.getElementById('macdClose');
  const overlay = document.getElementById('loading');
  const liveBtn = document.getElementById('liveBtn');

  const showLoading = ()=> overlay.style.display='flex';
  const hideLoading = ()=> overlay.style.display='none';

  const indCache = {
    ema20:null, rsi14:null, macd:{line:null,signal:null,hist:null},
    markers:{ trendRider:[], volBreakout:[] }
  };

  // tout OFF au démarrage
  let currentFlags = { ema20:false, rsi:false, macd:false, showTR:false, showVB:false };

  const GAP_BARS=4, MIN_PX_GAP=56; let LAST_TIME=0, TF_SEC=60, autoGap=true, autoY=true;
  let isSyncingLogical=false;

  function cap(a){ return a.length>MAX_MARKERS ? a.slice(-MAX_MARKERS) : a; }
  function collectMarkers(){
    const out=[];
    if(currentFlags.showTR) out.push(...cap(indCache.markers.trendRider));
    if(currentFlags.showVB) out.push(...cap(indCache.markers.volBreakout));
    return cap(out);
  }
  function refreshMarkers(){ candleSeries.setMarkers(collectMarkers()); }

  function syncLogicalFrom(srcChart, logical){
    if(isSyncingLogical) return;
    isSyncingLogical=true;
    const r = logical ?? srcChart.timeScale().getVisibleLogicalRange();
    if(r){
      if(priceChart && srcChart!==priceChart) priceChart.timeScale().setVisibleLogicalRange(r);
      if(rsiChart   && srcChart!==rsiChart)   rsiChart.timeScale().setVisibleLogicalRange(r);
      if(macdChart  && srcChart!==macdChart)  macdChart.timeScale().setVisibleLogicalRange(r);
      updateLiveFrom(priceChart);
    }
    isSyncingLogical=false;
  }
  function updateLiveFrom(chart){
    if(!LAST_TIME){ liveBtn.classList.toggle('live', autoGap&&autoY); return; }
    const tr = chart.timeScale().getVisibleRange(); if(!tr) return;
    const to = (typeof tr.to==='object'&&tr.to)?tr.to.time:tr.to; if(!to) return;
    autoGap = (LAST_TIME - to) <= TF_SEC*0.6; refreshLiveBadge();
  }

  const priceChart = LightweightCharts.createChart(priceDiv, {
    autoSize:false,
    layout:{ background:{type:'Solid', color:'#0e1116'}, textColor:'#cfd3dc' },
    rightPriceScale:{ visible:true, borderVisible:true, drawTicks:true, scaleMargins:{ top:0.1, bottom:0.1 } },
    leftPriceScale:{ visible:false },
    timeScale:{ rightOffset:0, borderVisible:false, fixRightEdge:false, shiftVisibleRangeOnNewBar:false },
    grid:{ vertLines:{ visible:false }, horzLines:{ visible:false } },
    crosshair:{ mode: LightweightCharts.CrosshairMode.Normal },
    handleScroll:{ pressedMouseMove:true, mouseWheel:true, horzTouchDrag:true, vertTouchDrag:false },
    handleScale:{ axisPressedMouseMove:{ time:true, price:true }, mouseWheel:true, pinch:true }
  });
  const candleSeries = priceChart.addCandlestickSeries();

  let ema20Series=null;
  let rsiChart=null, rsiSeries=null;
  let macdChart=null, macdLineSeries=null, macdSignalSeries=null, macdHistSeries=null;

  function createRsiChart(){
    if(rsiChart) return;
    rsiChart = LightweightCharts.createChart(rsiDiv, {
      autoSize:false,
      layout:{ background:{type:'solid', color:'#0f131a'}, textColor:'#e5e7eb' },
      grid:{ vertLines:{color:'#1f2937'}, horzLines:{color:'#1f2937'} },
      rightPriceScale:{ borderVisible:false }, timeScale:{ borderVisible:false },
      handleScroll:{ pressedMouseMove:true, mouseWheel:true, horzTouchDrag:true, vertTouchDrag:false },
      handleScale:{ axisPressedMouseMove:{ time:true, price:true }, mouseWheel:true, pinch:true }
    });
    rsiSeries = rsiChart.addLineSeries({ lineWidth:2, title:'RSI 14' });
    rsiSeries.createPriceLine({ price:70, color:'#94a3b8', lineWidth:1, lineStyle:LightweightCharts.LineStyle.Dotted, axisLabelVisible:true, title:'70' });
    rsiSeries.createPriceLine({ price:30, color:'#94a3b8', lineWidth:1, lineStyle:LightweightCharts.LineStyle.Dotted, axisLabelVisible:true, title:'30' });
    if(indCache.rsi14) rsiSeries.setData(indCache.rsi14);
    rsiChart.timeScale().subscribeVisibleLogicalRangeChange((r)=>{ if(r) syncLogicalFrom(rsiChart,r); });
    syncLogicalFrom(priceChart);
  }
  function destroyRsiChart(){ if(!rsiChart) return; rsiChart.remove(); rsiChart=null; rsiSeries=null; }

  function createMacdChart(){
    if(macdChart) return;
    macdChart = LightweightCharts.createChart(macdDiv, {
      autoSize:false,
      layout:{ background:{type:'solid', color:'#0f131a'}, textColor:'#e5e7eb' },
      grid:{ vertLines:{color:'#1f2937'}, horzLines:{color:'#1f2937'} },
      rightPriceScale:{ borderVisible:false }, timeScale:{ borderVisible:false },
      handleScroll:{ pressedMouseMove:true, mouseWheel:true, horzTouchDrag:true, vertTouchDrag:false },
      handleScale:{ axisPressedMouseMove:{ time:true, price:true }, mouseWheel:true, pinch:true }
    });
    macdLineSeries   = macdChart.addLineSeries({ lineWidth:2, title:'MACD' });
    macdSignalSeries = macdChart.addLineSeries({ lineWidth:1, title:'Signal' });
    macdHistSeries   = macdChart.addHistogramSeries({ base:0, priceFormat:{ type:'price', precision:5, minMove:0.00001 } });
    if(indCache.macd.line)   macdLineSeries.setData(indCache.macd.line);
    if(indCache.macd.signal) macdSignalSeries.setData(indCache.macd.signal);
    if(indCache.macd.hist)   macdHistSeries.setData(indCache.macd.hist);
    macdChart.timeScale().subscribeVisibleLogicalRangeChange((r)=>{ if(r) syncLogicalFrom(macdChart,r); });
    syncLogicalFrom(priceChart);
  }
  function destroyMacdChart(){ if(!macdChart) return; macdChart.remove(); macdChart=null; macdLineSeries=macdSignalSeries=macdHistSeries=null; }

  function ensureSizes(){
    const w=Math.floor(root.clientWidth), h=Math.floor(root.clientHeight);
    if(w<=0||h<=0) return;
    let priceH=Math.max(240, Math.floor(h*0.65));
    let extra=0;
    if(rsiDiv.style.display!=='none') extra+=160;
    if(macdDiv.style.display!=='none') extra+=160;
    priceH=Math.max(180, h - extra - 40);
    priceChart.resize(w, priceH);
    if(rsiChart) rsiChart.resize(w,160);
    if(macdChart) macdChart.resize(w,160);
  }

  function keepGapIfNeeded(){
    if(!LAST_TIME) return;
    const x = priceChart.timeScale().timeToCoordinate(LAST_TIME);
    if(x==null) return;
    const pxGap = root.clientWidth - x;
    if(autoGap && pxGap < MIN_PX_GAP) priceChart.timeScale().scrollToPosition(GAP_BARS,false);
  }
  function ensureLastBarVisible(){
    if(!LAST_TIME) return;
    const x = priceChart.timeScale().timeToCoordinate(LAST_TIME);
    if(x==null){
      const n=120, from=LAST_TIME - n*TF_SEC, to=LAST_TIME + GAP_BARS*TF_SEC;
      priceChart.timeScale().setVisibleRange({from,to});
      if(rsiChart) rsiChart.timeScale().setVisibleRange({from,to});
      if(macdChart) macdChart.timeScale().setVisibleRange({from,to});
    } else { keepGapIfNeeded(); }
  }
  function refreshLiveBadge(){ liveBtn.classList.toggle('live', autoGap&&autoY); }
  function goLive(){
    autoGap=true; autoY=true;
    priceChart.priceScale('right').applyOptions({ autoScale:true });
    if(LAST_TIME){
      const from=LAST_TIME-200*TF_SEC, to=LAST_TIME+GAP_BARS*TF_SEC;
      priceChart.timeScale().setVisibleRange({from,to});
      if(rsiChart) rsiChart.timeScale().setVisibleRange({from,to});
      if(macdChart) macdChart.timeScale().setVisibleRange({from,to});
    }else{
      priceChart.timeScale().fitContent();
      if(rsiChart) rsiChart.timeScale().fitContent();
      if(macdChart) macdChart.timeScale().fitContent();
    }
    requestAnimationFrame(()=>{ priceChart.timeScale().scrollToPosition(GAP_BARS,false); keepGapIfNeeded(); refreshLiveBadge(); });
  }
  liveBtn.addEventListener('click', goLive);

  priceChart.timeScale().subscribeVisibleLogicalRangeChange((r)=>{ if(r) syncLogicalFrom(priceChart,r); });

  function isOnRightScale(ev, el, chart){
    const rect=el.getBoundingClientRect();
    const ps=chart.priceScale('right'); const psw=(ps && typeof ps.width==='function')?ps.width():60;
    const x=('clientX' in ev)?ev.clientX:(ev.touches&&ev.touches[0]?ev.touches[0].clientX:null);
    if(x==null) return false;
    return x >= (rect.right - psw - 6);
  }
  ['wheel','mousedown','touchstart'].forEach(evt=>{
    priceDiv.addEventListener(evt,(e)=>{
      if(isOnRightScale(e, priceDiv, priceChart)){ autoY=false; priceChart.priceScale('right').applyOptions({ autoScale:false }); }
      else { autoGap=false; }
      refreshLiveBadge();
    },{ passive:true });
  });
  ;['wheel','mousedown','touchstart'].forEach(evt=>{
    [rsiDiv, macdDiv].forEach(el=> el.addEventListener(evt, ()=>{ autoGap=false; refreshLiveBadge(); }, { passive:true }));
  });
  priceDiv.addEventListener('dblclick',(e)=>{
    if(isOnRightScale(e,priceDiv,priceChart)){ autoY=true; priceChart.priceScale('right').applyOptions({ autoScale:true }); refreshLiveBadge(); }
    else { const r=priceChart.timeScale().getVisibleLogicalRange(); if(!r){ priceChart.timeScale().fitContent(); return; }
           const mid=(r.from+r.to)/2, half=(r.to-r.from)*1.35/2; priceChart.timeScale().setVisibleLogicalRange({from:mid-half, to:mid+half}); syncLogicalFrom(priceChart); }
  });

  function toBar(b){ return { time:b.time, open:b.open, high:b.high, low:b.low, close:b.close }; }
  function resizeAll(){ ensureSizes(); }
  window.addEventListener('load', resizeAll);
  window.addEventListener('resize', resizeAll);
  new ResizeObserver(resizeAll).observe(root);

  if (window.qt && typeof QWebChannel !== 'undefined') {
    new QWebChannel(qt.webChannelTransport, (channel) => {
      const bridge = channel.objects.bridge;

      const closePane = (div, destroyFn, key) => {
        div.style.display='none'; destroyFn && destroyFn();
        bridge.notifyIndicatorClose && bridge.notifyIndicatorClose(key); resizeAll();
      };
      rsiClose.addEventListener('click',  ()=> closePane(rsiDiv,  destroyRsiChart,  'rsi'));
      macdClose.addEventListener('click', ()=> closePane(macdDiv, destroyMacdChart, 'macd'));

      bridge.showLoading.connect(showLoading);
      bridge.hideLoading.connect(hideLoading);

      bridge.seriesLoaded.connect((jsonStr) => {
        const bars = JSON.parse(jsonStr).map(toBar);
        candleSeries.setData(bars);
        HAS_INITIAL = true;

        if (bars.length) {
          LAST_TIME = bars[bars.length-1].time;
          TF_SEC = bars.length>=2 ? Math.max(1, bars[bars.length-1].time - bars[bars.length-2].time) : TF_SEC;
        }
        priceChart.timeScale().fitContent();
        requestAnimationFrame(()=>{ priceChart.timeScale().scrollToPosition(4,false); ensureLastBarVisible(); });
        hideLoading();
      });

      bridge.barUpdated.connect((jsonStr) => {
        const bar = toBar(JSON.parse(jsonStr));
        if (!HAS_INITIAL) {
          candleSeries.setData([bar]);
          HAS_INITIAL = true;
          LAST_TIME = bar.time;
        } else {
          candleSeries.update(bar);
          if (bar.time >= LAST_TIME) LAST_TIME = bar.time;
        }
        ensureLastBarVisible();
      });


      bridge.indicatorsLoaded.connect((json)=>{
        const d=JSON.parse(json||'{}');
        indCache.ema20 = d.ema20 || null;
        indCache.rsi14 = d.rsi14 || null;
        indCache.macd  = { line:d.macd&&d.macd.line||null, signal:d.macd&&d.macd.signal||null, hist:d.macd&&d.macd.hist||null };
        indCache.markers = d.markers || { trendRider:[], volBreakout:[] };
        Object.keys(indCache.markers).forEach(k=> indCache.markers[k]=cap(indCache.markers[k]));
        if(ema20Series && indCache.ema20) ema20Series.setData(indCache.ema20);
        if(rsiSeries  && indCache.rsi14)  rsiSeries.setData(indCache.rsi14);
        if(macdLineSeries && indCache.macd.line)   macdLineSeries.setData(indCache.macd.line);
        if(macdSignalSeries && indCache.macd.signal) macdSignalSeries.setData(indCache.macd.signal);
        if(macdHistSeries && indCache.macd.hist)   macdHistSeries.setData(indCache.macd.hist);
        refreshMarkers(); ensureSizes();
      });

      bridge.indicatorUpdated.connect((json)=>{
        const p=JSON.parse(json||'{}');
        if(p.ema20 && ema20Series) ema20Series.update(p.ema20);
        if(p.rsi14 && rsiSeries)   rsiSeries.update(p.rsi14);
        if(p.macd){
          if(macdLineSeries)   macdLineSeries.update({ time:p.macd.time, value:p.macd.macd });
          if(macdSignalSeries) macdSignalSeries.update({ time:p.macd.time, value:p.macd.signal });
          if(macdHistSeries)   macdHistSeries.update({ time:p.macd.time, value:p.macd.hist });
        }
        if(p.markers){
          ['trendRider','volBreakout'].forEach(k=>{
            if(p.markers[k] && p.markers[k].length){
              indCache.markers[k].push(...p.markers[k]);
              indCache.markers[k] = cap(indCache.markers[k]);
            }
          });
          refreshMarkers();
        }
      });

      // toggles depuis Python
      bridge.indicatorToggle.connect((json)=>{
        const f=JSON.parse(json||'{}');
        currentFlags = { ...currentFlags, ...f };

        if(currentFlags.ema20){
          if(!ema20Series)
            // ⬇️ ICI: EMA jaune (avant c’était la couleur par défaut bleue)
            ema20Series = priceChart.addLineSeries({ lineWidth:2, title:'EMA 20', color:'#facc15' });
          if(indCache.ema20) ema20Series.setData(indCache.ema20);
        } else if(ema20Series){
          priceChart.removeSeries(ema20Series); ema20Series=null;
        }

        if(currentFlags.rsi){
          rsiDiv.style.display='block'; if(!rsiChart) createRsiChart(); if(indCache.rsi14 && rsiSeries) rsiSeries.setData(indCache.rsi14);
          syncLogicalFrom(priceChart);
        } else { rsiDiv.style.display='none'; if(rsiChart) destroyRsiChart(); }

        if(currentFlags.macd){
          macdDiv.style.display='block'; if(!macdChart) createMacdChart(); syncLogicalFrom(priceChart);
        } else { macdDiv.style.display='none'; if(macdChart) destroyMacdChart(); }

        refreshMarkers();
        requestAnimationFrame(()=>{ ensureSizes(); ensureLastBarVisible(); });
      });
    });
  }
</script>
</body>
</html>
